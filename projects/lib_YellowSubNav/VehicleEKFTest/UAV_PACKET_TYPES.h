//=============================================================================
/** @file UAV_PACKET_TYPES.h
 *
 * @brief
 *	Type definitions and constants used in conjunction with UAVnet format
 *	network packets.
 *
 * @note
 *	Ported from UAV_PACKET_TYPES.lib Dynamic C library checked out on 4-18-2011
 */
//=============================================================================


/*** BeginHeader, packet_key_cvs, packet_key_html, packet2csv, packet2html, print_csv_keys */
#ifndef UAV_PACKET_TYPES_H
#define UAV_PACKET_TYPES_H

#include <stdint.h>		// Standard sized integer type definitions


//--------------------------------------------------------------
/* IMPORTANT: UAVnet was originally designed for 8-bit Rabbit
 * microcontrollers.  Due to their 8-bit data bus, these Rabbit
 * micros used single-Byte-aligned memory addressing.  By
 * contrast, PC platforms (i386, amd64) generally do their
 * addressing aligned to 4-Byte (32-bit) boundaries.  As a
 * result, we must enable structure packing to be able to
 * access fields in UAVnet packets.  This results in larger,
 * slower code for the PC in order to accommodate unaligned
 * structure accesses, but it is necessary to accommodate the
 * legacy Rabbit code
 */
#pragma pack(push, 1)	// This should work for gcc and Visual Studio 2010+


namespace UAVnet
{

//===========================
// CONSTANTS
//===========================

/** @enum e_PacketSizes
 * @brief Size constants common to all UAVnet packets
 */
enum e_PacketSizes
{
	UAVNET_PACKET_SIZE = 128
};


/** @def UAVNET_HEADER_SIZE
 * @brief
 *	Size of a UAVnet packet header
 */
#define UAVNET_HEADER_SIZE 	sizeof(UAVnet::PacketHeader_t)




/** @enum e_UavNetPacketTypeIds
 * @brief
 *	Integer ID's used in the PacketType field of a UAVnet packet header to
 *	identify the type of information conveyed in the packet's payload.
 */
enum e_UavNetPacketTypeIds
{
	TYPE_GENERIC = 0, 	// 0 Generic packet type
	TYPE_GENERIC_LOG,	// 1
	TYPE_SENSOR,		// 2 Sensor readings sent by SPOCK
	TYPE_SENSOR_LOG,	// 3
	TYPE_CONTROLS,		// 4 SCOTTY servo positions and motor speed
	TYPE_CONTROLS_LOG,	// 5
	TYPE_COMMAND,		// 6 Command from one controller to another
	TYPE_COMMAND_LOG,	// 7
	TYPE_LBL_POS,		// 8 Position information from Woods Hole Modem or GPS
	TYPE_LBL_POS_LOG,	// 9
	TYPE_WHM_MSG,		// 10 Message received from the WHOI acoustic modem
	TYPE_WHM_MSG_LOG,	// 11
	TYPE_GPGGA,			// 12 GPS info
	TYPE_GPGGA_LOG,		// 13
	TYPE_BUOY_POS,    	// 14 LBL buoy positions sent from Uhura to Kirk.
	TYPE_BUOY_POS_LOG,	// 15
	TYPE_KALMAN,		// 16 Kalman filter info
	TYPE_KALMAN_LOG,	// 17
	TYPE_IMU,			// 18 "IMU" message contents from the Archangel IMU
	TYPE_IMU_LOG,		// 19
	TYPE_TELEMETRY,		// 20 Telemetry packet sent from Kirk to DSP
	TYPE_TELEMETRY_LOG,	// 21
	TYPE_AHRS,			// 22 "AHRS" messages from the Archangel IMU
	TYPE_AHRS_LOG,		// 23
	TYPE_SYNCH_RANGE,	// 24 Synchronous navigation range
	TYPE_SYNCH_RANGE_LOG,// 25
	TYPE_KALMSHIP,		// 26 Used for logging of the ship EKF
	TYPE_KALMSHIP_LOG,	// 27
	TYPE_DEPTH, 		// 28 Used for high rate depth sensor logging
	TYPE_DEPTH_LOG,		// 29
	TYPE_EKFTEST_IMU_MSG,	/* Generated by the EKFTest app to split apart
							   TYPE_IMU_LOG packets */
	NUM_PACKET_TYPEIDS
};


// These may be used to identify a command_packet.
// All Command numbers start with "CMD_"
/** @enum e_CommandTypeIds
 * @brief
 *	Command type ID's sent in the "command" field of a Command packet
 */
enum e_CommandTypeIds
{
	CMD_SET_TRIM,			// 0(0x00) Set the trim parameters for SCOTTIE
	CMD_ABORT,				// 1(0x01) Abort/stop current mission
	CMD_START_MISSION,		// 2(0x02) Run a new mission
	CMD_ZERO,				// 3(0x03) Zero selected sensors
	CMD_REQ_LOG_TABLE,		// 4(0x04) Request log table
	CMD_SEND_LOG_TABLE,		// 5(0x05) Send one entry of log table
	CMD_REQ_LOG_RUN,		// 6(0x06) Request log entries for single run
	CMD_RESET_LOG,			// 7(0x07) Resets log to beginning
	CMD_END_OF_FILE,		// 8(0x08) Indicates end of log table or log run
	CMD_REQ_MSG,			// 9(0x09) Requests leader message from Kirk
	CMD_REPORT_RPM,			// 10(0x0A) Propulsion reports RPM of motor
	CMD_REQ_TRIM,			// 11(0x0B) Asks for trim parameters from SCOTTIE
	CMD_SET_LEADER_BROADCAST,// 12(0x0C) KIRK-->UHURA: enable broadcast
	CMD_BUOYS_RECEIVED,		// 13(0x0D) Kirk-->Uhura: ACK buoy location packet.
	CMD_START_RECORDER,		// 14(0x0E) Kirk requests DSP recording start.
	CMD_STOP_RECORDER,		// 15(0x0F) Kirk requests DSP recording stop.
	CMD_RESTART_RECORDER,	// 16(0x10) Kirk requests DSP recording restart.
	CMD_QUERY_RECORDER,		// 17(0x11) Kirk queries DSP record engine state
	CMD_GPS_DATE,			// 18(0x12) Report of Date of Position fix
	CMD_START_32BYTE 		// 19(0x13) 32-Byte "start mission" message.
};



/** @enum e_AbortTypeIds
 * @brief
 *	ID's indicating the reason for a mission abort
 */
enum e_AbortCodes
{
	ABORT_NORM,			// 0(0x00) normal abort/mission complete
	ABORT_MANUAL,		// 1(0x01) abort from keyboard input (debug only)
	ABORT_UHURA,		// 2(0x02) abort received from UHURA
	ABORT_VOLTAGE,		// 3(0x03) battery voltage too low
	ABORT_H2O,			// 4(0x04) water leak detected
	ABORT_RUN_TIME,	// 5(0x05) run length too long
	ABORT_DEPTH,		// 6(0x06) depth too great
	ABORT_TILT,			// 7(0x07) pitch too great
	ABORT_DIST,			// 8(0x08) distance from waypoint too great (GPS only)
	ABORT_BAD_POS,		// 9(0x09) too many bad position packets
	ABORT_NO_DIVE,		// 10(0x0A) failed to dive
	ABORT_LEADER,		// 11(0x0B) commanded to abort by leader
	ABORT_KALMAN,		// 12(0x0C) kalman filter jump
	ABORT_BADRANGES,	// 13(0x0D) kalman filter abort if 10 bad ranges
	ABORT_INVERT, // 14(0x0E) kalman filter abort if failed invert
	ABORT_BAD_IMU,    // 15(0x0F) Imu is not responding
	ABORT_OFF_COURSE	// 16(0x10) Vehicle is too far off of course
};




/** @enum e_UavnetWhoiMessageTypeIds
 * @brief
 * 	ID's used in the msg_size_type field of TYPE_WHM_MSG and TYPE_WHM_MSG_LOG
 *	packets to indicate the type of message it contains
 */
enum e_WhoiMessageTypeIds
{
	BIT13,
	BYTE32,
	SYNCH_BUOY
};





//===========================
// DATA TYPES
//===========================


//------------------------------------------
/** @typedef PacketHeader_t
 *
 * @brief
 * 	Data structure forming the packet header that all UAVnet packets begin
 *	with.
 */
typedef struct
{
	uint16_t Type;		/**< Packet type from e_UavNetPacketTypeIds */
	uint16_t SourceId;	/**< ID of the device sending the packet */
	uint16_t DestId;	/**< ID of the device the packet is addressed to */
	uint16_t Reserved;	/**< <b> Reserved for future use */
	uint32_t MsTimeStamp;	/**< Millisecond time stamp associated with the
								 packet data */
} PacketHeader_t;





//------------------------------------------
/** @typedef GenericPacket_t
 * @brief
 * 	Data structure used to represent a generic, typeless UAVnet packet.
 *
 * @par Packet Type
 *	TYPE_GENERIC, TYPE_GENERIC_LOG
 */
typedef struct
{
	PacketHeader_t Header;		/**< Packet header */
	char Payload[UAVNET_PACKET_SIZE - sizeof(PacketHeader_t)]; /**< payload
																	data */
} GenericPacket_t;



//------------------------------------------
/** @typedef SensorPacket_t
 * @brief
 *	Sensor data sent by SPOCK
 *
 * @par Packet Type
 *	TYPE_SENSOR, TYPE_SENSOR_LOG
 */
typedef struct
{
	PacketHeader_t Header;		/**< Packet header */
	float CompassHeading;		/**< Digital compass heading (degrees) */
	float Depth_cm;				/**< Depth from pressure sensor (centimeters) */
	float BatteryVoltage;		/**< Battery bus voltage */
	uint16_t WaterLeakDetected;	/**< Water leak detected flag (1 = TRUE;
									 2 = FALSE */

	float Temperature_C;		/**< Internal vehicle temperature (degrees C) */

	float GPS_Longitude;		/**< GPS longitude */
	float GPS_Latitude;			/**< GPS latitude */
	float GPS_Velocity;			/**< GPS velocity (meters per second) */
	float GPS_HPE;				/**< GPS horizontal position error */
	float GPS_Heading;			/**< GPS heading (degrees) */

	//ACCELLEROMETER
	float Accelerometer_X;		/**< Acceleration about X-axis */
	float Accelerometer_Y;		/**< Acceleration about Y-axis */

	float Pitch;				/**< Vehicle pitch (degrees) */
	float Roll;					/**< Vehicle roll (degrees) */
	float Dip;					/**< Vehicle dip (degrees) */
	float BatteryCurrent;		/**< Battery current (currently unused) */
	float BatteryCharge;		/**< Battery charge (currently unused) */
	float YawRate;				/**< Yaw rate (degrees per second) */
	uint16_t GPS_Hours;				/**< GPS Time: hour in the day */
	uint16_t GPS_Minutes;			/**< GPS Time: minute in the hour */
	uint16_t GPS_Seconds;			/**< GPS Time: second in the minute */
	int32_t GPS_PpsMs;				/**< Milliseconds since midnight derived from
										 GPS PPS */

	char Pad[ UAVNET_PACKET_SIZE - (sizeof(PacketHeader_t) +
			  17*sizeof(float) + 4*sizeof(uint16_t) + sizeof(int32_t)) ]; // 92

} SensorPacket_t;




//------------------------------------------
/** @typedef ControlsPacket_t
 * @brief
 *	Sent from KIRK to SCOTTY to communicate actuator controls
 *
 * @par Packet Type
 *	TYPE_CONTROLS, TYPE_CONTROLS_LOG
 */
typedef struct
{
	PacketHeader_t Header;		/**< Packet header */
	int16_t DesiredThrust;		/**< Desired propeller thrust +/-(0 to 100%) */
	int16_t ControlType;		/**< Control packet type (currently unused) */
	int16_t RudderAngle;		/**< Rudder angle (degrees) */
	int16_t ElevatorAngle;		/**< Right elevator angle (degrees) */
	int16_t AileronAngle;		/**< Left elevator angle (degrees) */
	uint16_t WaypointNumber;	/**< Target waypoint number */
	uint16_t MissionMode;		/**< Current mission mode */
	float PathVector_North;		/**< North component of vehicle's path vector */
	float PathVector_East;		/**< East component of vehicle's path vector */
	float EstPosVector_North;	/**< North component of estimated position
									 vector */
	float EstPosVector_East;	/**< East component of estimated position
									 vector */
	float TargetVector_N;		/**< North component of target vector */
	float TargetVector_E;		/**< East component of target vector */
	float ReferenceHeading;		/**< Reference heading */
	float HeadingError;			/**< Difference between desired heading and
									 current heading */
	float DistanceFromPath;		/**< Distance from path vector (TRAJ control
									 only) */
	float TargetVectorDistance;	/**< Length of target vector */
	float DistanceSoFar;		/**< Distance traveled after reaching current
									 target waypoint */
	float DistanceRemaining;	/**< Distance remaining to current target
									 waypoint */
	float DepthErrorSum;		/**< integrated depth error control value */
	float PerpDistanceSum;		/**< integrated perpendicular distance Control
									 Value */

	char Pad[UAVNET_PACKET_SIZE -
	         (14*sizeof(float) + 5*sizeof(int16_t) + 2*sizeof(int16_t) +
	          sizeof(PacketHeader_t))];
} ControlsPacket_t;




//------------------------------------------
/** @typedef CommandPacket_t
 * @brief
 *	Sent from KIRK to SCOTTY to communicate actuator controls
 *
 * @par Packet Type
 *	TYPE_COMMAND, TYPE_COMMAND_LOG
 */
typedef struct
{
	PacketHeader_t Header;		/**< Packet header */
	int16_t CommandId;			/**< Command ID from e_CommandTypeIds */
	int16_t Parameter[10];		/**< Command parameters */

	char Pad[UAVNET_PACKET_SIZE - (sizeof(PacketHeader_t) +
								   11*sizeof(int16_t) )];
} CommandPacket_t;





//------------------------------------------
/** @typedef LblEstPositionPacket_t
 * @brief
 *	Packet sent from UHURA to KIRK containing the estimated vehicle position
 *	based on ranges from LBL transponder beacons.
 *
 * @par Packet Type
 *	TYPE_LBL_POS, TYPE_LBL_POS_LOG
 */
typedef struct{
	PacketHeader_t Header;		/**< Packet header */
	float Position_N;			/**< North component of the buoy position */
	float Position_E;			/**< East component of the buoy position */
	long TimeStamp;				/**< Time stamp of position information */
	char BuoyBitmap;			/**< Bitmap of buoys used to calculate the
									 position */
	float Range_A;				/**< Range (meters) to Buoy A */
	float Range_B;				/**< Range (meters) to Buoy B */
	float Range_C;				/**< Range (meters) to Buoy C */
	float Range_D;				/**< Range (meters) to Buoy D */

	char Pad[UAVNET_PACKET_SIZE - (6*sizeof(float) +
			 sizeof(long) + sizeof(char) + sizeof(PacketHeader_t))];
} LblEstPositionPacket_t;




//------------------------------------------
/** @typedef WhoiMsgPacket_t
 * @brief
 *	Packet containing a message from the WHOI acoustic modem: sent from UHURA
 * to KIRK
 *
 * @par Packet Type
 *	TYPE_WHM_MSG, TYPE_WHM_MSG_LOG
 */
typedef struct
{
	PacketHeader_t Header;		/**< Packet header */
	uint16_t MessageTypeId;		/**< TypeID from e_WhoiMessageTypeIds
									 indicating the type of message contained
									 in the packet */
	uint16_t DestVehicleID;		/**< Acoustic ID the message is addressed to */
	uint16_t SourceVehicleID;	/**< Acoustic ID the message was sent from */

	char MessageData[UAVNET_PACKET_SIZE - (3*sizeof(int16_t) +
					 sizeof(PacketHeader_t))]; //16
} WhoiMsgPacket_t;




//------------------------------------------
/** @typedef GpsGPGGAPacket_t
 * @brief
 *	Contains a GPGGA NMEA sentence from the Garmin GPS18x
 *
 * @par Packet Type
 *	TYPE_GPGGA, TYPE_GPGGA_LOG
 */
typedef struct
{
	PacketHeader_t Header;		/**< Packet header */
	char gpgga_msg[UAVNET_PACKET_SIZE - sizeof(PacketHeader_t)];
} GpsGPGGAPacket_t;




//------------------------------------------
/** @typedef LblBeaconLocationPacket_t
 * @brief
 *	Packet sent from Uhura to Kirk containing the positions of LBL transponder
 *	beacons A through D.
 *
 * @par Packet Type
 *	TYPE_BUOY_POS, TYPE_BUOY_POS_LOG
 */
typedef struct
{
	PacketHeader_t Header;		/**< Packet header */
	uint16_t SoundSpeedInH2O;	/**< Velocity of sound in water (meters/sec)*/
	int32_t OriginLatitude;	/**< Latitude of coordinate system origin */
	int32_t OriginLongitude;	/**< Longitude of coordinate system origin */

	float BeaconA_N;			/**< North coordinate of LBL beacon A */
	float BeaconA_E;			/**< East coordinate of LBL beacon A */
	float BeaconA_Depth;		/**< Depth of LBL beacon A */

	float BeaconB_N;			/**< North coordinate of LBL beacon B */
	float BeaconB_E;			/**< East coordinate of LBL beacon B */
	float BeaconB_Depth;		/**< Depth of LBL beacon B */

	float BeaconC_N;			/**< North coordinate of LBL beacon C */
	float BeaconC_E;			/**< East coordinate of LBL beacon C */
	float BeaconC_Depth;		/**< Depth of LBL beacon C */

	float BeaconD_N;			/**< North coordinate of LBL beacon D */
	float BeaconD_E;			/**< East coordinate of LBL beacon D */
	float BeaconD_Depth;		/**< Depth of LBL beacon D */

	char Pad[UAVNET_PACKET_SIZE - (sizeof(uint16_t) + 2*sizeof(int32_t) +
								   12*sizeof(float) + sizeof(PacketHeader_t))];	// 70
} LblBeaconLocationPacket_t;




//------------------------------------------
/** @typedef VehicleEKFPacket_t
 * @brief
 *	Packet containing vehicle EKF data (mostly used for logging)
 *
 * @par Packet Type
 *	TYPE_KALMAN, TYPE_KALMAN_LOG
 */
typedef struct
{
	PacketHeader_t Header;	/**< Packet header */
	float State_1;
	float State_2;
	float State_3;
	float State_4;
	float State_5;
	float P_1_1;
	float P_2_2;
	float P_3_3;
	float P_4_4;
	float P_5_5;
	float Delta_Time;
	float Z_gyro;
	float P_1_2;
	float P_1_3;
	float P_1_4;
	float P_1_5;
	float P_2_3;
	float P_2_4;
	float P_2_5;
	float P_3_4;
	float P_3_5;
	float P_4_5;

	char Pad[UAVNET_PACKET_SIZE - (22*sizeof(float) + sizeof(PacketHeader_t))];	// 100
} VehicleEKFPacket_t;




//------------------------------------------
/** @typedef ShipEKFPacket_t
 * @brief
 *	Packet containing data from the (target) ship EKF (mostly used for logging)
 *
 * @par Packet Type
 *	TYPE_KALMSHIP, TYPE_KALMSHIP_LOG
 */
typedef struct
{
	PacketHeader_t Header;	/**< Packet header */
	float State_1;
	float State_2;
	float State_3;
	float State_4;
	float P_1_1;
	float P_2_2;
	float P_3_3;
	float P_4_4;
	float Delta_Time;
	float P_1_2;
	float P_1_3;
	float P_1_4;
	float P_2_3;
	float P_2_4;
	float P_3_4;
	char Pad[UAVNET_PACKET_SIZE - (15*sizeof(float) + sizeof(PacketHeader_t))]; // 72
} ShipEKFPacket_t;




//------------------------------------------
/** @typedef DepthField_t
 * @brief
 *	A data structure used in high-rate depth packets
 */
typedef struct
{
	uint32_t time;// 4
	float pressure;    // 8
} DepthField_t;




//------------------------------------------
/** @typedef DepthField_t
 * @brief
 *	A packet used to record high-rate depth sensor (pressure) measurements
 *
 * @par Packet Type
 *	TYPE_DEPTH, TYPE_DEPTH_LOG
 */
typedef struct
{
	PacketHeader_t Header;	/**< Packet header */
	DepthField_t depth_field[14];
	char Pad[UAVNET_PACKET_SIZE - (14*sizeof(DepthField_t) +
								  sizeof(PacketHeader_t))];
} DepthPacket_t;



/*typedef struct{
	unsigned long  ms_time;
	float accX;
	float accY;
	float accZ;
	float gyrA;
	float gyrB;
	float gyrC;
}t_imudat;	// size 24 bytes

typedef struct{			//Added: 3/13/09  Added to include a packet allowing KIRK to record IMU data.
	PACKET_HEADER      				// 12 generic packet header info
	t_imudat imudata[4]; 			// 108

   char pad[PACKET_SIZE - 108];
}imu_packet;   */






//------------------------------------------
/** @typedef ImuMessage_t
 * @brief
 *	Data structure holding the sensor readings in a single "IMU" message from
 *	the Archangel IM^3 IMU module.  Used in IMU packets.
 */
typedef struct
{
	uint32_t TimeStampMs;	/**< Millisecond time stamp associated with the
								 sensor readings */
	float Acc_X;			/**< X accelerometer reading */
	float Acc_Y;			/**< Y accelerometer reading */
	float Acc_Z;			/**< Z accelerometer reading */
	float GyroA;			/**< Gyro A reading */
	float GyroB;			/**< Gyro B reading */
	float GyroC;			/**< Gyro C reading */
} ImuMessage_t;


//------------------------------------------
/** @typedef ImuPacket_t
 * @brief
 *	A packet used to record "IMU" messages from the Archangel IM^3 IMU
 *
 * @par Packet Type
 *	TYPE_IMU, TYPE_IMU_LOG
 */
typedef struct
{			//Added: 3/13/09  Added to include a packet allowing KIRK to record IMU data.
	PacketHeader_t Header;	/**< Packet header */

	ImuMessage_t Reading[4];	/**< IMU message contents */

	char Pad[UAVNET_PACKET_SIZE - (4*sizeof(ImuMessage_t) +
								   sizeof(PacketHeader_t))];
} ImuPacket_t;



//------------------------------------------
/** @typedef SingleImuPacket_t
 * @brief
 *	A packet generated by the EKFTest application that contains a single "IMU"
 *	message from the Archangel IM^3 IMU
 *
 * @par Packet Type
 *	TYPE_EKFTEST_IMU_MSG
 */
typedef struct
{
	PacketHeader_t Header;	/**< Packet header */

	ImuMessage_t Reading;	/**< IMU message contents */

	char Pad[UAVNET_PACKET_SIZE - (sizeof(ImuMessage_t) +
								   sizeof(PacketHeader_t))];

} SingleImuPacket_t;





/*typedef struct{
//	long  ms_time;
	float roll;
	float pitch;
	float yaw;
	float rollrate;
	float pitchrate;
	float yawrate;
}t_ahrsdat;

typedef struct{			//Added: 3/13/09  Added to include a packet allowing KIRK to record IMU data.
	PACKET_HEADER      				// 12 generic packet header info
	t_ahrsdat ahrsdata[4]; 			// 108

   char pad[PACKET_SIZE - 108];
}imu_packet;   */


/*
typedef struct{			//Added: 3/13/09  Added to include a packet allowing KIRK to record IMU data.
	PACKET_HEADER      	// 12 generic packet header info
   float roll1;         // 16
   float pitch1;    	   // 20
   float yaw1;		      // 24
   float rollrate1;		// 28
	float pitchrate1;		// 32
	float yawrate1;		// 36
   float roll2;         // 40
   float pitch2;    	   // 44
   float yaw2;		      // 48
   float rollrate2;		// 52
	float pitchrate2;		// 56
	float yawrate2;		// 60
   float roll3;         // 64
   float pitch3;    	   // 68
   float yaw3;		      // 72
   float rollrate3;		// 76
	float pitchrate3;		// 80
	float yawrate3;		// 84
   float roll4;         // 88
   float pitch4;    	   // 92
   float yaw4;		      // 96
   float rollrate4;		// 100
	float pitchrate4;		// 104
	float yawrate4;		// 108

	char pad[PACKET_SIZE - 108];
}ahrs_packet;
*/




//------------------------------------------
/** @typedef DspTelemetryPacket_t
 * @brief
 *	Telemetry data sent to the DSP to be recorded with magnetic data.
 *
 * @par Packet Type
 *	TYPE_TELEMETRY, TYPE_TELEMETRY_LOG
 */
typedef struct
{
	PacketHeader_t Header;	/**< Packet header */
	float EKF_north_pos;	/**< Estimated north coordinate from EKF */
	float EKF_east_pos;		/**< Estimated east coordinate from EKF */
	float depth_cm;			/**< Measured depth (cm) */
	float Roll_deg;			/**< Measured vehicle roll (degrees) */
	float Pitch_deg;		/**< Measured vehicle pitch (degrees) */
	float CompassHeading_deg;	/**< Digital compass heading (degrees) */
	char Pad[UAVNET_PACKET_SIZE - (6*sizeof(float) + sizeof(PacketHeader_t))];
} DspTelemetryPacket_t;





//------------------------------------------
/** @typedef DspTelemetryPacket_t
 * @brief
 *	Packet used to send WHOI modem synchronous navigation ranges from UHURA to
 *	KIRK
 *
 * @par Packet Type
 *	TYPE_SYNCH_RANGE, TYPE_SYNCH_RANGE_LOG
 */
typedef struct
{
	PacketHeader_t Header;	/**< Packet header */
	uint32_t TimeStamp;		/**< Timestamp of position info */
	float ArrivalTime_sec;	/**< TOA value (seconds) */
	float Range_m;			/**< Distance to the target beacon in meters. */
	int16_t BeaconId;		/**< ID of the target beacon */
	int16_t CycleId;		/**< Cycle */
	int16_t ClockMode;		/**< Synch Mode needs to be 3 */
	int16_t RxQuality;		/**< Receive quality reported by WHOI modem */
	float Doppler;			/**< Doppler value reported by WHOI modem */

	char Pad[UAVNET_PACKET_SIZE - (sizeof(PacketHeader_t) + sizeof(int32_t) +
			 	 	 	 	 	   3*sizeof(float) + 4*sizeof(int16_t))]; // 36
} SynchronousRangePacket_t;




typedef union
{
	GenericPacket_t* AsGenericPacket;
	SensorPacket_t* AsSensorPacket;
	ControlsPacket_t* AsControlsPacket;
	CommandPacket_t* AsCommandPacket;
	LblEstPositionPacket_t* AsLblEstPositionPacket;
	WhoiMsgPacket_t* AsWhoiMsgPacket;
	GpsGPGGAPacket_t* AsGpsGPGGAPacket;
	LblBeaconLocationPacket_t* AsLblBeaconLocationPacket;
	VehicleEKFPacket_t* AsVehicleEKFPacket;
	ShipEKFPacket_t* AsShipEKFPacket;
	DepthPacket_t* AsDepthPacket;
	ImuPacket_t* AsImuPacket;
	DspTelemetryPacket_t* AsDspTelemetryPacket;
	SynchronousRangePacket_t* SynchronousRangePacket;
	void* AsRawBytes;
} PacketPointer_t;


}	// END namespace UAVnet


#pragma pack(pop)	// Restore default/previous structure packing

#endif

/*
xmem void packet2csv( packet* pp, char* buf_s );
xmem void packet2html( packet* pp, char* buf_s );
xmem void print_csv_keys(void);

const char packet_key_cvs[] =
"heading,pitch,roll,dip,depth,batvolts,batcurrent,batcharge,h2oleak,yawrate,\
temperature,lon,lat,time_hour:time_min:time_sec,gps_velocity,gps_HPE,gps_heading,\
XAcceleration,YAcceleration,PPS_elapsed_ms";

const char packet_key_html[] =
"<tr bgcolor=ffddcc ><th>heading</th><th>pitch</th><th>roll</th><th>dip</th><th>depth</th><th>batvolts</th><th>batcurrent</th><th>batcharge</th><th>h2oleak</th><th>yawrate</th><th>\
temperature</th><th>long_degrees</th><th>long_minutes</th><th>long_direction</th><th>lat_degrees</th><th>lat_minutes</th><th>\
lat_direction</th><th>time</th><th>gps_velocity</th><th>gps_HPE</th><th>gps_heading</th><th>\
XAcceleration</th><th>YAcceleration</th><th>PPS_elapsed_ms</th><th>cntrl_velocity</th><th>cntrl_rudder</th><th>cntrl_relev</th><th>cntrl_lelev</th></tr>";

#endif



xmem void print_csv_keys(void)
{

	printf("\n");
   printf("BEGIN PACKET KEYS\n");

	printf("KEY(SENSR){'HEADING','PITCH','ROLL','DIP','DEPTH','VOLTS','CURRENT',\
'CHARGE','WATER','YAW','TEMP','LONG_DEG','LAT_DEG','TIME_HOUR','TIME_MIN',\
'TIME_SEC','GPS_VEL','GPS_HPE','GPS_HEADING','X_ACCEL','Y_ACCEL','GPS_PPS_MS'}\n");

	printf("KEY(CNTRL){'MOTOR_SPEED','RUDDER','ELEVATOR','AILERON','WP_NUM',\
'CTRL_MODE','PATH_NORTH','PATH_EAST','EST_NORTH','EST_EAST','TARG_NORTH',\
'TARG_EAST','HREF','HEAD_ERR','DIST_PATH','TARG_LENGTH','TOTAL_PROG',\
'DIST_REM','DEPTH_INT','DIST_INT'}\n");

   printf("KEY(POSTN){'POS_NORTH','POS_EAST','POS_TIME','POS_BUOYMAP',\
'POS_RANGE_A','POS_RANGE_B','POS_RANGE_C','POS_RANGE_D'}\n");

   printf("KEY(WHMSG){'WHMSG_TYPE','WHMSG_SRC','WHMSG_DEST','WHMSG_TEXT'}\n");

   printf("KEY(SPEED){'RPM_PERCENT'}\n");

   printf("KEY(KALMN){'KALM_NORTH','KALM_EAST','KALM_SPEED','KALM_HEAD',\
'KALM_H_BIAS','KALM_COV_N','KALM_COV_E','KALM_COV_U','KALM_COV_H','KALM_COV_B',\
'KALM_DT','KALM_ZGYRO','KALM_COV_12','KALM_COV_13','KALM_COV_14','KALM_COV_15',\
'KALM_COV_23','KALM_COV_24','KALM_COV_25','KALM_COV_34','KALM_COV_35','KALM_COV_45'}\n");

   printf("KEY(KALMS){'KALMS_EAST','KALMS_NORTH','KALMS_SPEED','KALMS_HEADING',\
'KALMS_COV_E','KALMS_COV_N','KALMS_COV_S','KALMS_COV_H','KALMS_DT','KALMS_COV_12',\
'KALMS_COV_13','KALMS_COV_14','KALMS_COV_23','KALMS_COV_24','KALMS_COV_34'}\n");

   printf("KEY(IMU_T){'IMU_T','IMU_ACC_X','IMU_ACC_Y','IMU_ACC_Z','IMU_ROT_X',\
'IMU_ROT_Y','IMU_ROT_Z'}\n");

   printf("KEY(DEPTH_T){'DEPTH_T','DEPTH_PRESSURE'}\n");

   printf("KEY(AHRS){'IMU_AHRS_T','IMU_ROLL','IMU_PITCH','IMU_YAW','IMU_ROLL_RATE',\
'IMU_PITCH_RATE','IMU_YAW_RATE'}\n");

   printf("KEY(RANGE){'BUOY','CYCLE','TIMESTAMP','ARRIVAL','DISTANCE','CLK_MODE',\
'QUALITY','DOPPLER'}\n");

   printf("KEY(BUOYP){'SSH2O','ZERO_LAT','ZERO_LONG','BUOY_AX','BUOY_AY','BUOY_AZ',\
'BUOY_BX','BUOY_BY','BUOY_BZ','BUOY_CX','BUOY_CY','BUOY_CZ','BUOY_DX','BUOY_DY','BUOY_DZ'}\n");

   printf("KEY(TELEM){'TELEM_NORTH','TELEM_SOUTH','TELEM_DEPTH','TELEM_ROLL','TELEM_PITCH','TELEM_HEADING'}\n");

//   printf("KEY(SERVO){'RPM_PERCENT','RPM','RUDDER','RT_ELEV','LT_ELEV'}\n");

   printf("END PACKET KEYS\n");

   printf("\n");
}



xmem void packet2csv( packet* pp, char* buf_s )
{

	struct tm time;
   char timestamp[16];
	sensor_packet *sense_pp;
	command_packet *cmd_pp;
	controls_packet *cntrl_pp;
	position_packet *pos_pp;
	whm_msg_packet *whm_msg_pp;
	buoy_pos_packet *buoy_pos_pp;			//Added: 7/30/08   Added to create a buoy position packet pointer
	kalman_packet *kalman_pp;				//Added: 8/12/08 Added to create a kalman packet pointer.
	imu_packet *imu_pp;						//Added: 3/13/09 Added to create an IMU packet pointer.
   telemetry_packet *telem_pp;			//Added: 6/23/09 Added to create a telemetery packet pointer
   gpgga_packet *gga_pp;			//Added: 6/23/09 Added to create a telemetery packet pointer
	synch_range_packet *range_pp; 		//Added: 4/12/10 Added to enable Synchronous Navigation.
	kalmship_packet *kalmship_pp;				//Added: 12/9/10 Added to create a ship kalman packet pointer.
   depth_packet *depth_pp;                //Added: 4/12/11 Added to create a depth packet pointer.

   // Decode timestamp
   sprintf(timestamp, "%u", pp->time_ms);
//   mktm( &time, pp->time_ms/1000 );
//   sprintf(timestamp,"%02d:%02d:%02d:%03d  ",\
//  	time.tm_hour,time.tm_min,time.tm_sec,pp->time_ms%1000);

   switch( pp->type )
   {
   case TYPE_GENERIC:
   case TYPE_GENERIC_LOG:
      sprintf( buf_s, "%sGENRC,%s", timestamp, &(pp->pad[0]) );
      break;

   case TYPE_SENSOR:
   case TYPE_SENSOR_LOG:
      sense_pp = (sensor_packet*)pp;

      sprintf( buf_s,
      	"%sSENSR,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%d,%.3f,%.3f,%.9f,%.9f,%02d:%02d:%02d,%.3f,%.3f,%.3f,%.3f,%.3f,%ld",timestamp, \
         sense_pp->heading, sense_pp->pitch, sense_pp->roll, sense_pp->dip, sense_pp->depth, sense_pp->batvolts, sense_pp->batcurrent,\
         sense_pp->batcharge, sense_pp->h2oleak, sense_pp->yawrate, sense_pp->temperature, sense_pp->lon, sense_pp->lat,\
         sense_pp->time_hour, sense_pp->time_min, sense_pp->time_sec, sense_pp->gps_velocity, sense_pp->gps_HPE, sense_pp->gps_heading,\
         sense_pp->XAcceleration, sense_pp->YAcceleration, sense_pp->time_PPS_ms  );
      break;

   case TYPE_CONTROLS:
   case TYPE_CONTROLS_LOG:
      cntrl_pp = (controls_packet*)pp;

      sprintf( buf_s,
      	"%sCNTRL,%d,%d,%d,%d,%d,%d,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f",timestamp,
      	cntrl_pp->motor_speed, cntrl_pp->rudder, cntrl_pp->elevator, cntrl_pp->aileron,
      	cntrl_pp->wp_num, cntrl_pp->mission_mode_current,
      	cntrl_pp->vect_path_n, cntrl_pp->vect_path_e,
      	cntrl_pp->vect_pos_est_n, cntrl_pp->vect_pos_est_e,
      	cntrl_pp->vect_targ_n, cntrl_pp->vect_targ_e,
      	cntrl_pp->href, cntrl_pp->heading_err,
      	cntrl_pp->dist_perp, cntrl_pp->targ_dist,
      	cntrl_pp->dist_total_prog, cntrl_pp->dist_rem,
			cntrl_pp->depth_err_sum, cntrl_pp->dist_perp_sum);
      break;

   case TYPE_COMMAND:
   case TYPE_COMMAND_LOG:
      cmd_pp = (command_packet*)pp;
      switch( cmd_pp->command )
      {
      case CMD_START_MISSION:
         sprintf( buf_s, "%sSTART,%d,%d,%d,%d,%d,%d,%02d/%02d/%02d",timestamp,
         	cmd_pp->parameter_1, cmd_pp->parameter_2,	cmd_pp->parameter_3, \
            cmd_pp->parameter_4, cmd_pp->parameter_5, cmd_pp->parameter_6, \
            cmd_pp->parameter_8, cmd_pp->parameter_7, cmd_pp->parameter_9 );
         break;

      case CMD_ABORT:
         sprintf( buf_s, "%sABORT,%d", timestamp, cmd_pp->parameter_1 );
         break;

      case CMD_REPORT_RPM:
      	sprintf( buf_s, "%sSPEED,%d", timestamp, cmd_pp->parameter_1 );
      	break;

      case CMD_BUOYS_RECEIVED:
      	sprintf( buf_s, "%sBUOYS-RECEIVED", timestamp);
         break;

	   case CMD_START_RECORDER: 	//Kirk requests BONES to start Recording.
      	sprintf( buf_s, "%sDSP-RECORD,%d,%d,%d", timestamp,
         	cmd_pp->parameter_1, cmd_pp->parameter_2, cmd_pp->parameter_3 );
      	break;

      case CMD_STOP_RECORDER:  	//Kirk requests BONES to stop Recording.
      	sprintf( buf_s, "%sDSP-STOP,%d,%d,%d", timestamp,
         	cmd_pp->parameter_1, cmd_pp->parameter_2, cmd_pp->parameter_3);
      	break;

      case CMD_RESTART_RECORDER:	//Temporary until DSP is full Function.
      	sprintf( buf_s, "%sDSP-NUDGE,%d,%d,%d,%d", timestamp,
         	cmd_pp->parameter_1, cmd_pp->parameter_2, cmd_pp->parameter_3, cmd_pp->parameter_4);
         break;

      case CMD_QUERY_RECORDER:	//Ask BONES about status
      	sprintf( buf_s, "%sDSP-QUERY,%d,%d,%d,%d,%d", timestamp,
         	cmd_pp->parameter_1, cmd_pp->parameter_2, cmd_pp->parameter_3,
            cmd_pp->parameter_4, cmd_pp->parameter_5);
         break;
      case CMD_REQ_MSG:	//Uhura has Requested a Message
      	sprintf( buf_s, "%sMSG_REQ,%d", timestamp, cmd_pp->parameter_1);
         break;
		default:
			*buf_s = '\0';
      break;
      }
      break;

   case TYPE_LBL_POS:
   case TYPE_LBL_POS_LOG:
   	pos_pp = (position_packet*)pp;
    	sprintf( buf_s, "%sPOSTN,%.3f,%.3f,%ld,%d,%.3f,%.3f,%.3f,%.3f", timestamp,
      						 pos_pp->pos_n, pos_pp->pos_e, pos_pp->timestamp,
                         pos_pp->buoy_bm, pos_pp->Range_A, pos_pp->Range_B,
                         pos_pp->Range_C, pos_pp->Range_D );
   	break;

	case TYPE_WHM_MSG:
	case TYPE_WHM_MSG_LOG:
      whm_msg_pp = (whm_msg_packet*)pp;
      sprintf( buf_s, "%sWHMSG,%d,%d,%d,%s", timestamp, whm_msg_pp->msg_size_flag, whm_msg_pp->vehicle_id_src, whm_msg_pp->vehicle_id_dest, whm_msg_pp->msg );
      break;

	case TYPE_BUOY_POS:  //Added: 7/30/08    Added to handle the new Buoy Position Packets and print them out during data download.
	case TYPE_BUOY_POS_LOG:
      buoy_pos_pp = (buoy_pos_packet*)pp;
      sprintf( buf_s, "%sBUOYP,%d,%ld,%ld,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f", timestamp,
      buoy_pos_pp->SSH20, buoy_pos_pp->Zero_Pt_N, buoy_pos_pp->Zero_Pt_E,
      buoy_pos_pp->BuoyA_N, buoy_pos_pp->BuoyA_E, buoy_pos_pp->BuoyA_Z,
		buoy_pos_pp->BuoyB_N, buoy_pos_pp->BuoyB_E, buoy_pos_pp->BuoyB_Z,
		buoy_pos_pp->BuoyC_N, buoy_pos_pp->BuoyC_E, buoy_pos_pp->BuoyC_Z,
		buoy_pos_pp->BuoyD_N, buoy_pos_pp->BuoyD_E, buoy_pos_pp->BuoyD_Z);
      break;

	case TYPE_KALMAN:  //Added:8/12/08    Added to handle the Kalman information packets and print them out during data download.
	case TYPE_KALMAN_LOG:
      kalman_pp = (kalman_packet*)pp;
      sprintf( buf_s, "%sKALMN,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f", timestamp,
      kalman_pp->State_1, kalman_pp->State_2,
	  kalman_pp->State_3, kalman_pp->State_4,
	  kalman_pp->State_5, kalman_pp->P_1_1,
	  kalman_pp->P_2_2, kalman_pp->P_3_3,
	  kalman_pp->P_4_4, kalman_pp->P_5_5,
	  kalman_pp->Delta_Time, kalman_pp->Z_gyro,
	  kalman_pp->P_1_2, kalman_pp->P_1_3,
	  kalman_pp->P_1_4, kalman_pp->P_1_5,
	  kalman_pp->P_2_3, kalman_pp->P_2_4,
	  kalman_pp->P_2_5, kalman_pp->P_3_4,
	  kalman_pp->P_3_5, kalman_pp->P_4_5);
      break;
	case TYPE_KALMSHIP: //Added 12/9/2010 Added to handle the ship kalman filter information packets and print them out during data download
	case TYPE_KALMSHIP_LOG:
	  kalmship_pp = (kalmship_packet*)pp;
      sprintf( buf_s, "%sKALMS,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f", timestamp,
      kalmship_pp->State_1, 	kalmship_pp->State_2,
	  kalmship_pp->State_3, 	kalmship_pp->State_4,
	  kalmship_pp->P_1_1, 		kalmship_pp->P_2_2,
	  kalmship_pp->P_3_3, 		kalmship_pp->P_4_4,
	  kalmship_pp->Delta_Time, 	kalmship_pp->P_1_2,
	  kalmship_pp->P_1_3,		kalmship_pp->P_1_4,
	  kalmship_pp->P_2_3, 		kalmship_pp->P_2_4,
	  kalmship_pp->P_3_4);
	  break;
	case TYPE_IMU:  //Added:3/13/08    Added to handle the IMU information packets and print them out during data download.
	case TYPE_IMU_LOG:
      imu_pp = (imu_packet*)pp;
      sprintf( buf_s, "%sIMU_T,%ld,%f,%f,%f,%f,%f,%f,%ld,%f,%f,%f,%f,%f,%f,%ld,%f,%f,%f,%f,%f,%f,%ld,%f,%f,%f,%f,%f,%f", timestamp,
      imu_pp->imuT1,	imu_pp->accX1, imu_pp->accY1, imu_pp->accZ1,
      imu_pp->gyrA1, imu_pp->gyrB1, imu_pp->gyrC1,
      imu_pp->imuT2,	imu_pp->accX2, imu_pp->accY2, imu_pp->accZ2,
      imu_pp->gyrA2, imu_pp->gyrB2, imu_pp->gyrC2,
      imu_pp->imuT3,	imu_pp->accX3, imu_pp->accY3, imu_pp->accZ3,
      imu_pp->gyrA3, imu_pp->gyrB3, imu_pp->gyrC3,
      imu_pp->imuT4,	imu_pp->accX4, imu_pp->accY4, imu_pp->accZ4,
      imu_pp->gyrA4, imu_pp->gyrB4, imu_pp->gyrC4);
      break;

   case TYPE_DEPTH:  //Added:4/12/11    Added to handle the high rate pressure information packets and print them out during data download. BA
	case TYPE_DEPTH_LOG:
      depth_pp = (depth_packet*)pp;
      sprintf( buf_s, "%sDEPTH_T,%ld,%f,%ld,%f,%ld,%f,%ld,%f,%ld,%f,%ld,%f,%ld,%f,%ld,%f,%ld,%f,%ld,%f,%ld,%f,%ld,%f,%ld,%f,%ld,%f", timestamp,
      depth_pp->depth_field[0].time,   depth_pp->depth_field[0].pressure,  depth_pp->depth_field[1].time,   depth_pp->depth_field[1].pressure,
      depth_pp->depth_field[2].time,   depth_pp->depth_field[2].pressure,  depth_pp->depth_field[3].time,   depth_pp->depth_field[3].pressure,
    	depth_pp->depth_field[4].time,   depth_pp->depth_field[4].pressure,  depth_pp->depth_field[5].time,   depth_pp->depth_field[5].pressure,
      depth_pp->depth_field[6].time,   depth_pp->depth_field[6].pressure,	depth_pp->depth_field[7].time,   depth_pp->depth_field[7].pressure,
      depth_pp->depth_field[8].time,   depth_pp->depth_field[8].pressure,  depth_pp->depth_field[9].time,   depth_pp->depth_field[9].pressure,
      depth_pp->depth_field[10].time,   depth_pp->depth_field[10].pressure,  depth_pp->depth_field[11].time,   depth_pp->depth_field[11].pressure,
      depth_pp->depth_field[12].time,   depth_pp->depth_field[12].pressure,	depth_pp->depth_field[13].time,	depth_pp->depth_field[13].pressure);
      break;


  	case TYPE_TELEMETRY:  //Added: 6/23/09 Added to create a telemetery packet log
	case TYPE_TELEMETRY_LOG:
      telem_pp = (telemetry_packet*)pp;
      sprintf( buf_s, "%sTELEMETRY,%f,%f,%f,%f,%f,%f", timestamp, \
      telem_pp->EKF_north_pos, telem_pp->EKF_east_pos, telem_pp->depth_cm,\
      telem_pp->roll_deg, telem_pp->pitch_deg, telem_pp->CompassHeading_deg);
      break;

   case TYPE_GPGGA:
   case TYPE_GPGGA_LOG:
      gga_pp = (gpgga_packet*)pp;
      sprintf( buf_s, "%s%s", timestamp, &(gga_pp->gpgga_msg[1]) );
      break;

   case TYPE_SYNCH_RANGE:
   case TYPE_SYNCH_RANGE_LOG:
		range_pp = (synch_range_packet*)pp;
		printf("%sRANGE,%d,%d,%ld,%.4f,%.4f,%d,%d,%.1f", timestamp, \
		range_pp->buoy_id,range_pp->cycle_id,\
		range_pp->timestamp,range_pp->arrival_time,range_pp->range,\
		range_pp->clock_mode,range_pp->receive_quality,range_pp->doppler);

   default:
		*buf_s = '\0';
      break;

   }//switch( p1.type )
}

xmem void packet2html( packet* pp, char* buf_s )
{
	sensor_packet *sense_pp;
	command_packet *cmd_pp;
	controls_packet *cntrl_pp;

   int chars_written;

   switch( pp->type )
   {
   case TYPE_GENERIC:
   case TYPE_GENERIC_LOG:
		*buf_s = '\0';
      break;

   case TYPE_SENSOR:
   case TYPE_SENSOR_LOG:
      sense_pp = (sensor_packet*)pp;

      chars_written = sprintf( buf_s, "<td>%.3f</td><td>%.3f</td><td>%.3f</td><td>%.3f</td>",
         sense_pp->heading, sense_pp->pitch, sense_pp->roll, sense_pp->dip );

      chars_written += sprintf( buf_s+chars_written, "<td>%.3f</td><td>%.3f</td><td>%.3f</td><td>%.3f</td><td>%d</td>",
			sense_pp->depth, sense_pp->batvolts, sense_pp->batcurrent, sense_pp->batcharge, sense_pp->h2oleak );

      chars_written += sprintf( buf_s+chars_written, "<td>%.3f</td><td>%.3f</td><td>%.6f</td>",
			sense_pp->yawrate, sense_pp->temperature, sense_pp->lon );

      chars_written += sprintf( buf_s+chars_written, "<td>%.6f</td><td>%d:%d:%d</td>",
			sense_pp->lat, sense_pp->time_hour, sense_pp->time_min, sense_pp->time_sec );

      chars_written += sprintf( buf_s+chars_written, "<td>%.3f</td><td>%.3f</td><td>%.3f</td><td>%.3f</td><td>%.3f</td><td>%.3f</td>",
         sense_pp->gps_velocity, sense_pp->gps_HPE, sense_pp->gps_heading, sense_pp->XAcceleration, sense_pp->YAcceleration, sense_pp->time_PPS_ms );
      break;

   case TYPE_CONTROLS:
   case TYPE_CONTROLS_LOG:
      cntrl_pp = (controls_packet*)pp;

      sprintf( buf_s, "<td>%d</td><td>%d</td><td>%d</td><td>%d</td>", cntrl_pp->motor_speed, cntrl_pp->rudder, cntrl_pp->elevator, cntrl_pp->aileron );
      break;

   case TYPE_COMMAND:
   case TYPE_COMMAND_LOG:
		*buf_s = '\0';
		break;

   default:
		*buf_s = '\0';
		break;
   }//switch( p1.type )
}
*/
